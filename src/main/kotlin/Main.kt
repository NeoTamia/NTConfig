package re.neotamia.config.main

import re.neotamia.config.NTConfig
import re.neotamia.config.annotation.ConfigHeader
import re.neotamia.config.annotation.ConfigVersion
import re.neotamia.config.migration.core.ConfigMigrationHelpers
import re.neotamia.config.migration.step.ConfigMigrationStep
import re.neotamia.config.migration.version.MigrationVersion
import re.neotamia.config.saveable.SaveableCommented
import re.neotamia.nightconfig.core.file.CommentedFileConfig
import re.neotamia.nightconfig.core.serde.DeserializerContext
import re.neotamia.nightconfig.core.serde.NamingStrategy
import re.neotamia.nightconfig.core.serde.SerializerContext
import re.neotamia.nightconfig.core.serde.TypeAdapter
import re.neotamia.nightconfig.core.serde.annotations.SerdeComment
import re.neotamia.nightconfig.core.serde.annotations.SerdeConfig
import re.neotamia.nightconfig.json.JsonFormat
import re.neotamia.nightconfig.toml.TomlFormat
import re.neotamia.nightconfig.yaml.YamlFormat
import java.lang.reflect.Type
import java.nio.file.Files
import java.nio.file.Path
import re.neotamia.nightconfig.core.Config

enum class Test {
    UWU,
    OWO
}

data class ResourceLocation(
    var namespace: String,
    var path: String
) {
    constructor(path: String) : this(path.substringBefore(":"), path.substringAfter(":"))
}

@ConfigHeader("This is a sample configuration file.\nGenerated by Kotlin Serialization.")
data class Config(
    @SerdeComment("The name of the configuration")
    val name: String = "Config",
    @ConfigVersion
    val version: Int = 2,
    @SerdeConfig(
        comments = [SerdeComment("Whether the configuration is enabled")],
        key = "isEnabled"
    )
    val enabled: Boolean = true,
    //    @SerdeSkip(SerdeSkip.SkipIf.ALWAYS)
    val decimals: Float = 0.5f,
    val double: Double = 0.123456789,
    val items: List<String> = listOf("item1", "item2", "item3"),
    val settings: Map<String, String> = mapOf("key1" to "value1", "key2" to "value2"),
    val nested: NestedConfig = NestedConfig(),
    val multiline: String =
        """
        This is a multiline
        string example.
        It preserves line breaks.
        """.trimIndent(),
    val test: Test = Test.OWO,
    val resource: ResourceLocation = ResourceLocation("example:resource_path"),
    val uneVariableOuLeNomPeutEtreTresLong: Boolean = true,
    val toto: Int = 42,
    val titi: Int = 24
)

data class NestedConfig(
    val description: String = "Nested Config",
    val count: Int = 10,
    val nested: InnerNestedConfig = InnerNestedConfig()
)

data class InnerNestedConfig(
    val flag: Boolean = false,
    val ratio: Double = 3.14
)

class ResourceLocationTypeAdapter : TypeAdapter<ResourceLocation, String> {
    override fun canHandle(type: Type): Boolean = type == ResourceLocation::class.java

    override fun serialize(value: ResourceLocation, type: Type, ctx: SerializerContext) = value.namespace + ":" + value.path

    override fun deserialize(value: String, type: Type, ctx: DeserializerContext) = ResourceLocation(value)
}

data class SaveableConfig(
    var name: String = "SaveableConfig",
    var value: Int = 100,
    var rl: ResourceLocation = ResourceLocation("minecraft:stone")
) : SaveableCommented {
    override fun save(fileConfig: CommentedFileConfig) {
        fileConfig.setHeaderComment("This is a saveable config file.\nYou can add comments to each entry.")

        fileConfig.set<String>("name", name)
        fileConfig.setComment("name", "The name of the saveable config")

        fileConfig.set<Int>("value", value)
        fileConfig.setComment("value", "An integer value")

        fileConfig.setTyped<ResourceLocation>("rl", rl)
        fileConfig.setComment("rl", "A resource location")
    }

    override fun load(fileConfig: CommentedFileConfig) {
        name = fileConfig.getStringOrElse("name", "SaveableConfig")
        value = fileConfig.getIntOrElse("value", 100)
        rl = fileConfig.getTypedOrElse("rl", ResourceLocation::class.java, ResourceLocation("minecraft:granite"))
    }
}

data class ServerConfig(
    @ConfigVersion(defaultVersion = "2")
    var version: Int = 2,
    var server: Server = Server()
)

data class Server(
    var id: String = "default",
    var port: Int = 25565
)

class ServerWrapStep : ConfigMigrationStep {
    override fun fromVersion(): MigrationVersion = MigrationVersion("1")

    override fun toVersion(): MigrationVersion = MigrationVersion("2")

    override fun migrate(config: Config) {
        ConfigMigrationHelpers.wrapValue(config, "server", "id")
    }
}

fun main() {
    val ntconfig = NTConfig()
    ntconfig.registerFormat(TomlFormat.instance(), "toml")
    ntconfig.registerFormat(YamlFormat.defaultInstance(), "yaml", "yml")
    ntconfig.registerFormat(JsonFormat.fancyInstance(), "json")
    ntconfig.setNamingStrategy(NamingStrategy.KEBAB_CASE)
    ntconfig.registerTypeAdapter(ResourceLocationTypeAdapter())

    // add registerConfig to keep it in memory or use singleton?

    val conf = Config()
    ntconfig.save("config.yml", conf)

    val saveableConf = SaveableConfig()
    ntconfig.save("saveable.yaml", saveableConf)
    ntconfig.load("saveable.yaml", saveableConf)

    ntconfig.registerMigrationSteps(ServerConfig::class.java, ServerWrapStep())
    val legacyPath = Path.of("server.json")
    if (!Files.exists(legacyPath)) {
        Files.writeString(legacyPath, """{"version":1,"server":"monserver"}""")
    }
    val migrated = ntconfig.migrateAndLoad(legacyPath, ServerConfig::class.java, ServerConfig())

    println("Loaded SaveableConfig: $saveableConf")
    println("Loaded ServerConfig: ${migrated.config}")
}
