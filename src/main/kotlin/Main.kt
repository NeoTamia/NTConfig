package re.neotamia.config.main;

import com.charleskorn.kaml.Yaml
import kotlinx.serialization.ExperimentalSerializationApi
import kotlinx.serialization.Serializable
import re.neotamia.config.NTConfig
import re.neotamia.config.adapter.TypeAdapter
import re.neotamia.config.annotation.ConfigHeader
import re.neotamia.config.annotation.ConfigProperty
import re.neotamia.config.json.JsonConfigFormat
import re.neotamia.config.json.JsonSerializer
import re.neotamia.config.naming.NamingStrategy
import re.neotamia.config.registry.SerializerRegistry
import re.neotamia.config.registry.TypeAdapterRegistry
import re.neotamia.config.toml.TomlConfigFormat
import re.neotamia.config.toml.TomlSerializer
import re.neotamia.config.yaml.YamlConfigFormat
import re.neotamia.config.yaml.YamlSerializer
import java.nio.file.Files
import java.nio.file.Path
import kotlin.io.path.extension

enum class Test {
    UWU,
    OWO
}

class ResourceLocation(val namespace: String, val path: String) {
    constructor(path: String) : this(path.substringBefore(":"), path.substringAfter(":"))
}

@ConfigHeader("This is a sample configuration file.\nGenerated by Kotlin Serialization.")
class Config(
    @ConfigProperty("The name of the configuration")
    val name: String = "Config",
    val version: Int = 1,
    @ConfigProperty(name = "isEnabled", value = "Whether the configuration is enabled")
    val enabled: Boolean = true,
    @ConfigProperty(exclude = true)
    val decimals: Float = 0.5f,
    val double: Double = 0.123456789,
    val items: List<String> = listOf("item1", "item2", "item3"),
    val settings: Map<String, String> = mapOf("key1" to "value1", "key2" to "value2"),
    val nested: NestedConfig = NestedConfig(),
    val multiline: String = """
        This is a multiline
        string example.
        It preserves line breaks.
    """.trimIndent(),
    val test: Test = Test.OWO,
    val resource: ResourceLocation = ResourceLocation("example:resource_path"),
    val uneVariableOuLeNomPeutEtreTresLong: Boolean = true,
) {
    override fun toString(): String {
        return "Config(name='$name', version=$version, enabled=$enabled, decimals=$decimals, double=$double, items=$items, settings=$settings, nested=$nested, multiline='$multiline')"
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as Config

        if (version != other.version) return false
        if (enabled != other.enabled) return false
        if (decimals != other.decimals) return false
        if (double != other.double) return false
        if (name != other.name) return false
        if (items != other.items) return false
        if (settings != other.settings) return false
        if (nested != other.nested) return false
        if (multiline != other.multiline) return false

        return true
    }

    override fun hashCode(): Int {
        var result = version
        result = 31 * result + enabled.hashCode()
        result = 31 * result + decimals.hashCode()
        result = 31 * result + double.hashCode()
        result = 31 * result + name.hashCode()
        result = 31 * result + items.hashCode()
        result = 31 * result + settings.hashCode()
        result = 31 * result + nested.hashCode()
        result = 31 * result + multiline.hashCode()
        return result
    }
}

class NestedConfig {
    val description: String = "Nested Config"
    val count: Int = 10
    val nested = InnerNestedConfig()

    override fun toString(): String {
        return "NestedConfig(description='$description', count=$count, nested=$nested)"
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as NestedConfig

        if (count != other.count) return false
        if (description != other.description) return false
        if (nested != other.nested) return false

        return true
    }

    override fun hashCode(): Int {
        var result = count
        result = 31 * result + description.hashCode()
        result = 31 * result + nested.hashCode()
        return result
    }
}

class InnerNestedConfig {
    val flag: Boolean = false
    val ratio: Double = 3.14

    override fun toString(): String {
        return "InnerNestedConfig(flag=$flag, ratio=$ratio)"
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as InnerNestedConfig

        if (flag != other.flag) return false
        if (ratio != other.ratio) return false

        return true
    }

    override fun hashCode(): Int {
        var result = flag.hashCode()
        result = 31 * result + ratio.hashCode()
        return result
    }
}

class ResourceLocationTypeAdapter : TypeAdapter<ResourceLocation> {
    override fun serialize(obj: ResourceLocation): Any {
        return "${obj.namespace}:${obj.path}"
    }

    override fun deserialize(data: Any, clazz: Class<ResourceLocation>): ResourceLocation {
        if (data is String) {
            return ResourceLocation(data.substringBefore(":"), data.substringAfter(":"))
        }
        throw IllegalArgumentException("Cannot deserialize $data to ResourceLocation")
    }
}

fun main() {
//    val ntConfig = NTConfig()
//    ntConfig.registry.registerConfigFormat(YamlConfigFormat())
//    ntConfig.registry.registerConfigFormat(JsonConfigFormat())
//    ntConfig.registry.registerConfigFormat(TomlConfigFormat())
//
//    val config = Config(version = 5)
//    val file = Path.of("config.toml")
//    ntConfig.save(file, config)
//
//    val loadedConfig = ntConfig.load<Config>(file)
//    println("Loaded Config: $loadedConfig")
//    println("Loaded Config == Original Config: ${loadedConfig == config}")

//    val serializerRegistry = SerializerRegistry()
//    val registry = TypeAdapterRegistry()
//
//    registry.register(ResourceLocation::class.java, ResourceLocationTypeAdapter())
//
//    serializerRegistry.register(YamlSerializer(registry))
//    serializerRegistry.register(JsonSerializer(registry))
//    serializerRegistry.register(TomlSerializer(registry))

    val config = Config()
//    Files.write(Path.of("config.json"), serializerRegistry.getSerializerFromExtension("json").serialize(config).toByteArray())
//    Files.write(Path.of("config.yaml"), serializerRegistry.getSerializerFromExtension("yaml").serialize(config).toByteArray())
//    Files.write(Path.of("config.toml"), serializerRegistry.getSerializerFromExtension("toml").serialize(config).toByteArray())
//
//    val loadedJsonConfig = serializerRegistry.getSerializerFromExtension("json").deserialize(Files.readString(Path.of("config.json")), Config::class.java)
//    val loadedTomlConfig = serializerRegistry.getSerializerFromExtension("yaml").deserialize(Files.readString(Path.of("config.yaml")), Config::class.java)
//    val loadedYamlConfig = serializerRegistry.getSerializerFromExtension("toml").deserialize(Files.readString(Path.of("config.toml")), Config::class.java)
//
//    println(loadedJsonConfig == config)
//    println(loadedTomlConfig == config)
//    println(loadedYamlConfig == config)

    val ntConfig = NTConfig()
    ntConfig.namingStrategy = NamingStrategy.KEBAB_CASE
    ntConfig.registerSerializer(YamlSerializer())
    ntConfig.registerSerializer(JsonSerializer())
    ntConfig.registerSerializer(TomlSerializer())
    ntConfig.typeAdapterRegistry.register(ResourceLocation::class.java, ResourceLocationTypeAdapter())

    ntConfig.save(Path.of("config.yaml"), config)
    ntConfig.save(Path.of("config.json"), config)
    ntConfig.save(Path.of("config.toml"), config)
}
