package re.neotamia.config.main

import re.neotamia.config.NTConfig
import re.neotamia.config.annotation.ConfigHeader
import re.neotamia.config.annotation.ConfigVersion
import re.neotamia.nightconfig.core.file.CommentedFileConfig
import re.neotamia.nightconfig.core.file.FileConfig
import re.neotamia.nightconfig.core.serde.DeserializerContext
import re.neotamia.nightconfig.core.serde.NamingStrategy
import re.neotamia.nightconfig.core.serde.SerializerContext
import re.neotamia.nightconfig.core.serde.TypeAdapter
import re.neotamia.nightconfig.core.serde.TypeConstraint
import re.neotamia.nightconfig.core.serde.annotations.SerdeComment
import re.neotamia.nightconfig.core.serde.annotations.SerdeConfig
import re.neotamia.nightconfig.json.JsonFormat
import re.neotamia.nightconfig.toml.TomlFormat
import re.neotamia.nightconfig.yaml.YamlFormat
import java.lang.reflect.ParameterizedType
import java.lang.reflect.Type
import java.nio.file.Path

enum class Test {
    UWU,
    OWO
}

data class ResourceLocation(
    var namespace: String,
    var path: String
) {
    constructor(path: String) : this(path.substringBefore(":"), path.substringAfter(":"))
}

@ConfigHeader("This is a sample configuration file.\nGenerated by Kotlin Serialization.")
data class Config(
    @SerdeComment("The name of the configuration") val name: String = "Config",
    @ConfigVersion val version: Int = 2,
    @SerdeConfig(
        comments = [SerdeComment("Whether the configuration is enabled")],
        key = "isEnabled"
    )
    val enabled: Boolean = true,
    //    @SerdeSkip(SerdeSkip.SkipIf.ALWAYS)
    val decimals: Float = 0.5f,
    val double: Double = 0.123456789,
    val items: List<String> = listOf("item1", "item2", "item3"),
    val settings: Map<String, String> = mapOf("key1" to "value1", "key2" to "value2"),
    val nested: NestedConfig = NestedConfig(),
    val multiline: String =
        """
        This is a multiline
        string example.
        It preserves line breaks.
        """.trimIndent(),
    val test: Test = Test.OWO,
    val resource: ResourceLocation = ResourceLocation("example:resource_path"),
    val uneVariableOuLeNomPeutEtreTresLong: Boolean = true,
    val toto: Int = 42,
    val titi: Int = 24
)

data class NestedConfig(
    val description: String = "Nested Config",
    val count: Int = 10,
    val nested: InnerNestedConfig = InnerNestedConfig()
)

data class InnerNestedConfig(
    val flag: Boolean = false,
    val ratio: Double = 3.14
)

class ResourceLocationTypeAdapter : TypeAdapter<ResourceLocation, String> {
    override fun canHandle(type: Type): Boolean = type == ResourceLocation::class.java

    override fun serialize(
        value: ResourceLocation,
        type: Type,
        ctx: SerializerContext
    ): String = value.namespace + ":" + value.path

    override fun deserialize(
        value: String,
        type: Type,
        ctx: DeserializerContext
    ): ResourceLocation = ResourceLocation(value)
}

interface Saveable {
    fun save(fileConfig: FileConfig)

    fun load(fileConfig: FileConfig)
}

interface SaveableCommented {
    fun save(fileConfig: CommentedFileConfig)

    fun load(fileConfig: CommentedFileConfig)
}

data class SaveableConfig(
    var name: String = "SaveableConfig",
    var value: Int = 100,
    var rl: ResourceLocation = ResourceLocation("minecraft:stone")
) : Saveable,
    SaveableCommented {
    override fun save(fileConfig: CommentedFileConfig) {
        fileConfig.setHeaderComment(
            "This is a saveable config file.\nYou can add comments to each entry."
        )

        fileConfig.set<String>("name", name)
        fileConfig.setComment("name", "The name of the saveable config")

        fileConfig.set<Int>("value", value)
        fileConfig.setComment("value", "An integer value")

        fileConfig.set<String>("rl", rl.namespace + ":" + rl.path)
        fileConfig.setComment("rl", "A resource location")
    }

    override fun save(fileConfig: FileConfig) {}

    override fun load(fileConfig: CommentedFileConfig) {
        name = fileConfig.getStringOrElse("name", "SaveableConfig")
        value = fileConfig.getIntOrElse("value", 100)
        //        rl = fileConfig.getOrElse<ResourceLocation>("rl",
        // ResourceLocation("minecraft:granite"));
        val rlString = fileConfig.getStringOrElse("rl", "minecraft:granite")
        rl = ResourceLocation(rlString)
    }

    override fun load(fileConfig: FileConfig) {}
}

enum class BodyPartTypeBasic {
    HEAD,
    CHEST,
    LEGS
}

enum class BodyPartTypeAdvanced {
    HEAD(BodyPartTypeBasic.HEAD),
    SHOULDERS(BodyPartTypeBasic.CHEST),
    ARMS(BodyPartTypeBasic.CHEST),
    HANDS(BodyPartTypeBasic.CHEST),
    CHEST(BodyPartTypeBasic.CHEST),
    THIGHS(BodyPartTypeBasic.LEGS),
    KNEES(BodyPartTypeBasic.LEGS),
    LEGS(BodyPartTypeBasic.LEGS),
    FEET(BodyPartTypeBasic.LEGS);

    constructor(bodyPart: BodyPartTypeBasic)
}

enum class BodyPartTypeRealistic {
    EYES(BodyPartTypeAdvanced.HEAD),
    LEFT_SHOULDER(BodyPartTypeAdvanced.SHOULDERS),
    RIGHT_SHOULDER(BodyPartTypeAdvanced.SHOULDERS),
    LEFT_ARM(BodyPartTypeAdvanced.ARMS),
    RIGHT_ARM(BodyPartTypeAdvanced.ARMS),
    LEFT_HAND(BodyPartTypeAdvanced.HANDS),
    RIGHT_HAND(BodyPartTypeAdvanced.HANDS),
    TOP_TORSO(BodyPartTypeAdvanced.CHEST),
    BOTTOM_TORSO(BodyPartTypeAdvanced.CHEST),
    LEFT_THIGH(BodyPartTypeAdvanced.THIGHS),
    RIGHT_THIGH(BodyPartTypeAdvanced.THIGHS),
    LEFT_KNEE(BodyPartTypeAdvanced.KNEES),
    RIGHT_KNEE(BodyPartTypeAdvanced.KNEES),
    LEFT_LEG(BodyPartTypeAdvanced.LEGS),
    RIGHT_LEG(BodyPartTypeAdvanced.LEGS),
    LEFT_FOOT(BodyPartTypeAdvanced.FEET),
    RIGHT_FOOT(BodyPartTypeAdvanced.FEET);

    constructor(advanced: BodyPartTypeAdvanced)
}

data class ObjectParts<T>(
    val type: T,
    val factor: Double
)

class OPTA<T> : TypeAdapter<ObjectParts<T>, Any> {
    override fun canHandle(type: Type): Boolean {
        if (type !is ParameterizedType) return false
        if (type.rawType != ObjectParts::class.java) return false
        return true
    }

    override fun serialize(
        value: ObjectParts<T>,
        type: Type,
        ctx: SerializerContext
    ): Map<*, *> = mapOf("type" to value.type.toString(), "factor" to value.factor)

    override fun deserialize(
        value: Any,
        type: Type,
        ctx: DeserializerContext
    ): ObjectParts<T> {
        val valueType = (type as ParameterizedType).actualTypeArguments[0]

        // Handle both Map and UnmodifiableConfig
        val typeStr: String
        val factor: Double
        when (value) {
            is Map<*, *> -> {
                typeStr =
                    value["type"] as? String
                        ?: throw IllegalArgumentException("Missing 'type' field")
                factor =
                    (value["factor"] as? Number)?.toDouble()
                        ?: throw IllegalArgumentException("Missing 'factor' field")
            }
            is re.neotamia.nightconfig.core.UnmodifiableConfig -> {
                typeStr =
                    value.get<String>("type")
                        ?: throw IllegalArgumentException("Missing 'type' field")
                factor =
                    value.get<Number>("factor")?.toDouble()
                        ?: throw IllegalArgumentException("Missing 'factor' field")
            }
            else ->
                throw IllegalArgumentException(
                    "Expected Map or UnmodifiableConfig, got ${value::class.java}"
                )
        }

        val enumType = valueType as Class<T>
        val enumValue = java.lang.Enum.valueOf(enumType as Class<out Enum<*>>, typeStr) as T
        return ObjectParts(enumValue, factor)
    }
}

data class Parts<T>(
    val enabled: Boolean,
    val parts: List<ObjectParts<T>>
)

class PTA<T> : TypeAdapter<Parts<T>, Any> {
    override fun canHandle(type: Type): Boolean {
        if (type !is ParameterizedType) return false
        if (type.rawType != Parts::class.java) return false
        return true
    }

    override fun serialize(
        value: Parts<T>,
        type: Type,
        ctx: SerializerContext
    ): Map<*, *> =
        mapOf(
            "enabled" to value.enabled,
            "parts" to value.parts.map { ctx.serializeValue(it) }
        )

    override fun deserialize(
        value: Any,
        type: Type,
        ctx: DeserializerContext
    ): Parts<T> {
        val enabled: Boolean
        val partsList: List<*>

        when (value) {
            is Map<*, *> -> {
                enabled =
                    value["enabled"] as? Boolean
                        ?: throw IllegalArgumentException("Missing 'enabled' field")
                partsList =
                    value["parts"] as? List<*>
                        ?: throw IllegalArgumentException("Missing 'parts' field")
            }
            is re.neotamia.nightconfig.core.UnmodifiableConfig -> {
                enabled =
                    value.get<Boolean>("enabled")
                        ?: throw IllegalArgumentException("Missing 'enabled' field")
                partsList =
                    value.get<List<*>>("parts")
                        ?: throw IllegalArgumentException("Missing 'parts' field")
            }
            else ->
                throw IllegalArgumentException(
                    "Expected Map or UnmodifiableConfig, got ${value::class.java}"
                )
        }

        // Extract the inner type T from Parts<T>
        val innerEnumType = (type as ParameterizedType).actualTypeArguments[0]

        // Create a parameterized ObjectParts<T> type manually
        val objectPartsType =
            object : ParameterizedType {
                override fun getActualTypeArguments(): Array<Type> = arrayOf(innerEnumType)

                override fun getRawType(): Type = ObjectParts::class.java

                override fun getOwnerType(): Type? = null
            }

        val parts =
            partsList.map {
                ctx.deserializeValue(it, TypeConstraint(objectPartsType)) as ObjectParts<T>
            }
        return Parts<T>(enabled, parts)
    }
}

data class BodyType(
    @SerdeComment("The sum of every basic-parts factors should be 1.0")
    val basicParts: List<ObjectParts<BodyPartTypeBasic>> = listOf(),
    @SerdeComment(
        "Each advanced-parts factor is a multiplier applied to the corresponding basic-part"
    )
    val advancedParts: Parts<BodyPartTypeAdvanced> = Parts(false, listOf()),
    @SerdeComment(
        "Each realistic-parts factor is a multiplier applied to the corresponding advanced-part"
    )
    val realisticParts: Parts<BodyPartTypeRealistic> = Parts(false, listOf())
)

data class BodyConfig(
    @ConfigVersion
    @SerdeComment("Never change this value unless you know what you are doing")
    var version: String = "0.1",
    @SerdeComment(
        """
Body type configuration.
Options:
 - Basic: Head, Chest, Legs
 - Advanced: Head, Shoulders, Arms, Hands, Chest, Thighs, Knees, Legs, Feet
 - Realistic: Eyes, Left/Right for Shoulder, Arm, Hand, Torso, Thigh, Knee, Leg, Foot
    """
    )
    val bodyType: BodyType =
        BodyType(
            basicParts =
                listOf(
                    ObjectParts(BodyPartTypeBasic.HEAD, 0.4),
                    ObjectParts(BodyPartTypeBasic.CHEST, 0.4),
                    ObjectParts(BodyPartTypeBasic.LEGS, 0.2)
                ),
            advancedParts =
                Parts(
                    enabled = false,
                    parts =
                        listOf(
                            ObjectParts(
                                BodyPartTypeAdvanced.SHOULDERS,
                                0.5
                            ),
                            ObjectParts(BodyPartTypeAdvanced.ARMS, 0.5),
                            ObjectParts(
                                BodyPartTypeAdvanced.HANDS,
                                0.3
                            ),
                            ObjectParts(
                                BodyPartTypeAdvanced.CHEST,
                                0.5
                            ),
                            ObjectParts(
                                BodyPartTypeAdvanced.THIGHS,
                                0.3
                            ),
                            ObjectParts(
                                BodyPartTypeAdvanced.KNEES,
                                0.2
                            ),
                            ObjectParts(BodyPartTypeAdvanced.LEGS, 0.2),
                            ObjectParts(BodyPartTypeAdvanced.FEET, 0.2)
                        )
                ),
            realisticParts =
                Parts(
                    enabled = false,
                    parts =
                        listOf(
                            ObjectParts(
                                BodyPartTypeRealistic.EYES,
                                0.5
                            ),
                            ObjectParts(
                                BodyPartTypeRealistic.LEFT_SHOULDER,
                                0.3
                            ),
                            ObjectParts(
                                BodyPartTypeRealistic
                                    .RIGHT_SHOULDER,
                                0.3
                            ),
                            ObjectParts(
                                BodyPartTypeRealistic.LEFT_ARM,
                                0.2
                            ),
                            ObjectParts(
                                BodyPartTypeRealistic.RIGHT_ARM,
                                0.2
                            ),
                            ObjectParts(
                                BodyPartTypeRealistic.LEFT_HAND,
                                0.1
                            ),
                            ObjectParts(
                                BodyPartTypeRealistic.RIGHT_HAND,
                                0.1
                            ),
                            ObjectParts(
                                BodyPartTypeRealistic.TOP_TORSO,
                                0.4
                            ),
                            ObjectParts(
                                BodyPartTypeRealistic.BOTTOM_TORSO,
                                0.4
                            ),
                            ObjectParts(
                                BodyPartTypeRealistic.LEFT_THIGH,
                                0.2
                            ),
                            ObjectParts(
                                BodyPartTypeRealistic.RIGHT_THIGH,
                                0.2
                            ),
                            ObjectParts(
                                BodyPartTypeRealistic.LEFT_KNEE,
                                0.1
                            ),
                            ObjectParts(
                                BodyPartTypeRealistic.RIGHT_KNEE,
                                0.1
                            ),
                            ObjectParts(
                                BodyPartTypeRealistic.LEFT_LEG,
                                0.1
                            ),
                            ObjectParts(
                                BodyPartTypeRealistic.RIGHT_LEG,
                                0.1
                            ),
                            ObjectParts(
                                BodyPartTypeRealistic.LEFT_FOOT,
                                0.1
                            ),
                            ObjectParts(
                                BodyPartTypeRealistic.RIGHT_FOOT,
                                0.1
                            )
                        )
                )
        )
)

class Box<T> {
    var value: T? = null

    constructor()
    constructor(value: T?) {
        this.value = value
    }
}

data class TestA(
    val list: List<Box<String>>
)

fun main() {
    val ntconfig = NTConfig()
    ntconfig.registerFormat(TomlFormat.instance(), "toml")
    ntconfig.registerFormat(YamlFormat.defaultInstance(), "yaml", "yml")
    ntconfig.registerFormat(JsonFormat.fancyInstance(), "json")
    ntconfig.setNamingStrategy(NamingStrategy.KEBAB_CASE)
    ntconfig.registerTypeAdapter(OPTA<BodyPartTypeBasic>())
    ntconfig.registerTypeAdapter(OPTA<BodyPartTypeAdvanced>())
    ntconfig.registerTypeAdapter(OPTA<BodyPartTypeRealistic>())
    ntconfig.registerTypeAdapter(PTA<BodyPartTypeBasic>())
    ntconfig.registerTypeAdapter(PTA<BodyPartTypeAdvanced>())
    ntconfig.registerTypeAdapter(PTA<BodyPartTypeRealistic>())

    //    ntconfig.registerTypeAdapter(ResourceLocationTypeAdapter())

    //    ntconfig.registerTypeAdapter(OPTA<BodyPartTypeBasic>())
    //    ntconfig.registerTypeAdapter(OPTA<BodyPartTypeAdvanced>())
    //    ntconfig.registerTypeAdapter(OPTA<BodyPartTypeRealistic>())
    //
    //    ntconfig.registerTypeAdapter(PTA<BodyPartTypeBasic>())
    //    ntconfig.registerTypeAdapter(PTA<BodyPartTypeAdvanced>())
    //    ntconfig.registerTypeAdapter(PTA<BodyPartTypeRealistic>())

    //    val conversionTable = ConversionTable()
    //    conversionTable.put(String::class.java) { ResourceLocation(it) }

    //    val conf = SaveableConfig()
    //
    //    ntconfig.save("saveable.yaml", conf)
    //    ntconfig.load("saveable.yaml", conf)
    //
    //    //    conf.name = ""
    //    //    conf.value = 1111
    //    //    conf.rl = ResourceLocation("minecraft", "aaaaaaaaaaaaa")
    //
    //    val fileConfig = CommentedFileConfig.builder(Path.of("saveable.yaml")).sync().build()
    //    conf.save(fileConfig)
    //    fileConfig.save()
    //    fileConfig.close()
    //
    //    val config = CommentedFileConfig.builder(Path.of("saveable.yaml")).sync().build()
    // //    val wrappedConfig = conversionTable.wrapRead(config)
    //    conf.name = ""
    //    conf.value = 1111
    //    conf.rl = ResourceLocation("minecraft", "aaaaaaaaaaaaa")
    //    println(conf)
    //    config.load()
    //    config.close()
    //    conf.load(config)
    // //    conf.load(wrappedConfig);
    //    println(conf)

    val conf = BodyConfig()
    val f = ntconfig.save(Path.of("bodyconfig.yaml"), conf)
    f.close()

    conf.version = "0.2"
    val fileConfig = ntconfig.load(Path.of("bodyconfig.yaml"), conf)
    println(conf)

    //    val config = Config()
    //    config.resource.namespace = "5555555555555555"
    //    val conf = ntconfig.load(Path.of("config.yml"), config);
    //    println("${conf == config}, $config")
    //
    //    val fileConfig = ntconfig.save(Path.of("config.yml"), config);
    //    println(fileConfig.getFloat("decimals"))
}
