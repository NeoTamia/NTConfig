package re.neotamia.config.main;

import re.neotamia.nightconfig.core.file.CommentedFileConfig
import re.neotamia.nightconfig.core.serde.DeserializerContext
import re.neotamia.nightconfig.core.serde.ObjectSerializer
import re.neotamia.nightconfig.core.serde.SerializerContext
import re.neotamia.nightconfig.core.serde.TypeConstraint
import re.neotamia.nightconfig.core.serde.ValueDeserializer
import re.neotamia.nightconfig.core.serde.ValueSerializer
import dev.dejvokep.boostedyaml.YamlDocument
import dev.dejvokep.boostedyaml.libs.org.snakeyaml.engine.v2.common.ScalarStyle
import dev.dejvokep.boostedyaml.route.Route
import dev.dejvokep.boostedyaml.serialization.standard.StandardSerializer
import dev.dejvokep.boostedyaml.settings.dumper.DumperSettings
import dev.dejvokep.boostedyaml.settings.general.GeneralSettings
import dev.dejvokep.boostedyaml.settings.loader.LoaderSettings
import re.neotamia.config.adapter.TypeAdapter
import re.neotamia.config.annotation.ConfigHeader
import re.neotamia.config.annotation.ConfigProperty
import re.neotamia.config.annotation.ConfigVersion
import re.neotamia.nightconfig.core.file.FormatDetector
import re.neotamia.nightconfig.core.serde.ObjectDeserializer
import re.neotamia.nightconfig.core.serde.annotations.SerdeComment
import re.neotamia.nightconfig.core.serde.annotations.SerdeKey
import re.neotamia.nightconfig.json.JsonFormat
import re.neotamia.nightconfig.toml.TomlFormat
import re.neotamia.nightconfig.yaml.YamlFormat
import java.io.File
import java.nio.file.Path
import java.util.Optional
import kotlin.jvm.java

enum class Test {
    UWU,
    OWO
}

class ResourceLocation(var namespace: String, val path: String) {
    constructor(path: String) : this(path.substringBefore(":"), path.substringAfter(":"))

    override fun toString(): String {
        return "ResourceLocation(namespace='$namespace', path='$path')"
    }
}

@ConfigHeader("This is a sample configuration file.\nGenerated by Kotlin Serialization.")
class Config(
    @ConfigProperty("The name of the configuration")
    @SerdeComment("The name of the configuration")
    val name: String = "Config",
    @ConfigVersion
    val version: Int = 2,
    @SerdeKey("isEnabled")
    @SerdeComment("The value of the configuration")
    @ConfigProperty(name = "isEnabled", value = "Whether the configuration is enabled")
    val enabled: Boolean = true,
    @ConfigProperty(exclude = true)
    // TODO: add support for floats
    val decimals: Double = 0.5,
    val double: Double = 0.123456789,
    val items: List<String> = listOf("item1", "item2", "item3"),
    val settings: Map<String, String> = mapOf("key1" to "value1", "key2" to "value2"),
    val nested: NestedConfig = NestedConfig(),
    val multiline: String = """
        This is a multiline
        string example.
        It preserves line breaks.
    """.trimIndent(),
    val test: Test = Test.OWO,
    val resource: ResourceLocation = ResourceLocation("example:resource_path"),
    val uneVariableOuLeNomPeutEtreTresLong: Boolean = true,
    val toto: Int = 42,
    val titi: Int = 24
) {
    override fun toString(): String {
        return "Config(name='$name', version=$version, enabled=$enabled, decimals=$decimals, double=$double, items=$items, settings=$settings, nested=$nested, multiline='$multiline')"
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as Config

        if (version != other.version) return false
        if (enabled != other.enabled) return false
        if (decimals != other.decimals) return false
        if (double != other.double) return false
        if (name != other.name) return false
        if (items != other.items) return false
        if (settings != other.settings) return false
        if (nested != other.nested) return false
        if (multiline != other.multiline) return false

        return true
    }

    override fun hashCode(): Int {
        var result = version
        result = 31 * result + enabled.hashCode()
        result = 31 * result + decimals.hashCode()
        result = 31 * result + double.hashCode()
        result = 31 * result + name.hashCode()
        result = 31 * result + items.hashCode()
        result = 31 * result + settings.hashCode()
        result = 31 * result + nested.hashCode()
        result = 31 * result + multiline.hashCode()
        return result
    }
}

class NestedConfig {
    val description: String = "Nested Config"
    val count: Int = 10
    val nested = InnerNestedConfig()

    override fun toString(): String {
        return "NestedConfig(description='$description', count=$count, nested=$nested)"
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as NestedConfig

        if (count != other.count) return false
        if (description != other.description) return false
        if (nested != other.nested) return false

        return true
    }

    override fun hashCode(): Int {
        var result = count
        result = 31 * result + description.hashCode()
        result = 31 * result + nested.hashCode()
        return result
    }
}

class InnerNestedConfig {
    val flag: Boolean = false
    val ratio: Double = 3.14

    override fun toString(): String {
        return "InnerNestedConfig(flag=$flag, ratio=$ratio)"
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as InnerNestedConfig

        if (flag != other.flag) return false
        if (ratio != other.ratio) return false

        return true
    }

    override fun hashCode(): Int {
        var result = flag.hashCode()
        result = 31 * result + ratio.hashCode()
        return result
    }
}

class ResourceLocationTypeAdapter : TypeAdapter<ResourceLocation>, ValueSerializer<ResourceLocation, String>, ValueDeserializer<String, ResourceLocation> {
    override fun serialize(obj: ResourceLocation): Any {
        return "${obj.namespace}:${obj.path}"
    }

    override fun deserialize(data: Any, clazz: Class<ResourceLocation>): ResourceLocation {
        if (data is String) {
            return ResourceLocation(data.substringBefore(":"), data.substringAfter(":"))
        }
        throw IllegalArgumentException("Cannot deserialize $data to ResourceLocation")
    }

    override fun serialize(value: ResourceLocation, ctx: SerializerContext): String {
        return "${value.namespace}:${value.path}"
    }

    override fun deserialize(value: String, resultType: Optional<TypeConstraint>, ctx: DeserializerContext): ResourceLocation {
        return ResourceLocation(value)
    }
}

//fun main() {
//    val config = Config()
//
//    val ntConfig = NTConfig()
//    ntConfig.namingStrategy = NamingStrategy.KEBAB_CASE
//    ntConfig.registerSerializer(YamlSerializer())
//    ntConfig.registerSerializer(JsonSerializer())
//    ntConfig.registerSerializer(TomlSerializer())
//    ntConfig.typeAdapterRegistry.register(ResourceLocation::class.java, ResourceLocationTypeAdapter())
//
////    ntConfig.save(Path.of("config.yaml"), config)
////    ntConfig.save(Path.of("config.json"), config)
////    ntConfig.save(Path.of("config.toml"), config)
//
//    val result = ntConfig.loadWithMigration(Path.of("config.yaml"), Config::class.java, config, MergeStrategy.MERGE_MISSING_ONLY)
//    println(result)
//}

fun main() {
    FormatDetector.registerExtension("toml", TomlFormat.instance())
    FormatDetector.registerExtension("yaml", YamlFormat.defaultInstance())
    FormatDetector.registerExtension("yml", YamlFormat.defaultInstance())
    FormatDetector.registerExtension("json", JsonFormat.fancyInstance())
    val config = CommentedFileConfig.builder(Path.of("config-night.toml")).sync().build()
    val objectSerializer = ObjectSerializer.builder().withSerializerForClass(ResourceLocation::class.java, ResourceLocationTypeAdapter()).build()
    objectSerializer.serializeFields(Config(), config)
    println(config)

    config.save()
    config.load()

    val deserializer = ObjectDeserializer.builder().withDeserializerForClass(String::class.java, ResourceLocation::class.java, ResourceLocationTypeAdapter()).build()
    val deserializedConfig = Config()
    deserializedConfig.resource.namespace = "9999999999999999"
    deserializer.deserializeFields(config, deserializedConfig)

    println(deserializedConfig.resource)
}

//fun main() {
//    val serializer = StandardSerializer.getDefault();
//    val document = YamlDocument.create(
//        File("config.yaml"),
//        DumperSettings.builder()
//            .setIndentation(2)
//            .setIndicatorIndentation(2)
//            .setMultilineStyle(true)
//            .build(),
//        LoaderSettings.builder().setCreateFileIfAbsent(true).setDetailedErrors(true).build(),
//        GeneralSettings.builder().setSerializer(serializer).build()
//    )
//    document.reload()
//    document.getOptional(Route.from("settings", "key1")).ifPresent { println(it) }
////    document.save()
//}
